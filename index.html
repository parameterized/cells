<title>cells</title>
<link rel="icon" type="image/png" href="favicon.png" />
<style>
    html, body {
        padding: 0;
        margin: 0;
        overflow: hidden;
        background-color: #262626;
    }
    canvas { display: block; }
</style>

<!-- fallback to cdn -->
<script src="lib/p5.js"></script>
<script>window.p5 || document.write('<script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.js">\x3C/script>')</script>
<script src="lib/swissgl.js"></script>
<script>window.SwissGL || document.write('<script src="https://cdn.jsdelivr.net/gh/google/swissgl@main/swissgl.js">\x3C/script>')</script>

<script>
    let pause = false;
    let canvas;
    let glsl, cells, targetMass;
    let perceptDists, perceptSharp;
    let weights1, bias1;
    let weights2, bias2;

    const cellsTargetParams = {
        scale: 1 / 6 / window.devicePixelRatio,
        format: "rgba16f",
        story: 2,
        tag: "cells",
    };

    function setup() {
        canvas = createCanvas(windowWidth, windowHeight, WEBGL);
        glsl = SwissGL(canvas.elt);
        cells = glsl({
            seed: Math.random() * 12417,
            FP: "hash(ivec3(I, seed)), 1"
        }, { ...cellsTargetParams });

        initWeights();
        frameRate(60);

        addEventListener("contextmenu", e => {
            e.preventDefault();
        });
        addEventListener("mousedown", e => {
            if (e.detail > 1) {
                e.preventDefault();
            }
        });

        setTimeout(() => {
            windowResized();
        }, 100);
    };

    function initWeights() {
        perceptDists = [];
        for (let i = 0; i < 3 * 3; i++) {
            perceptDists.push(random());
        }
        perceptDists = new Float32Array(perceptDists);

        perceptSharp = [];
        for (let i = 0; i < 3 * 3; i++) {
            perceptSharp.push(random(4, 16));
        }
        perceptSharp = new Float32Array(perceptSharp);

        weights1 = [];
        for (let i = 0; i < 9 * 6; i++) {
            weights1.push(random(-1, 1) * 10);
        }
        weights1 = new Float32Array(weights1);

        bias1 = [];
        for (let i = 0; i < 6; i++) {
            bias1.push(random());
        }
        bias1 = new Float32Array(bias1);

        weights2 = [];
        for (let i = 0; i < 6 * 3; i++) {
            weights2.push(random(-1, 1) * 10);
        }
        weights2 = new Float32Array(weights2);

        bias2 = [];
        for (let i = 0; i < 3; i++) {
            bias2.push(random());
        }
        bias2 = new Float32Array(bias2);
    }

    function keyPressed() {
        if (key === " ") {
            pause = !pause;
        } else if (key === "r") {
            glsl({ FP: "0" }, cells);
            step();
        } else if (key === "f") {
            glsl({ FP: "0" }, cells);
            initWeights();
            step();
        } else if (key === "ArrowRight") {
            step();
        }
    }

    function step() {
        targetMass = glsl({
            cells: cells[0],
            perceptDists,
            perceptSharp,
            w1: weights1,
            bias1,
            w2: weights2,
            bias2,
            FP: `
            uniform mat3 perceptDists;
            uniform mat3 perceptSharp;
            uniform vec3 w1[18];
            uniform vec3 bias1[2];
            uniform vec3 w2[6];
            uniform vec3 bias2;

            void fragment() {
                mat3 percept;
                mat3 perceptDivisor;

                for (int k = 0; k < 81; k++) {
                    ivec2 offset = ivec2(k % 9 - 4, k / 9 - 4);
                    if (offset == ivec2(0)) { continue; }
                    ivec2 neighborPos = (
                        I + offset + cells_size()
                    ) % cells_size();

                    float dist = length(vec2(offset)) / 5.0;
                    float circleMask = dist <= 1.0 ? 1.0 : 0.0;
                    mat3 shiftedDists = dist - perceptDists;
                    mat3 absDists = mat3(
                        abs(shiftedDists[0]),
                        abs(shiftedDists[1]),
                        abs(shiftedDists[2])
                    );
                    mat3 contribution = mat3(
                        exp(-perceptSharp[0] * absDists[0]),
                        exp(-perceptSharp[1] * absDists[1]),
                        exp(-perceptSharp[2] * absDists[2])
                    ) * circleMask;
                    perceptDivisor += contribution;

                    vec3 rgb = cells(neighborPos).rgb;
                    percept += mat3(
                        contribution[0] * rgb,
                        contribution[1] * rgb,
                        contribution[2] * rgb
                    );
                }

                percept /= perceptDivisor;

                mat3 p = percept;

                vec3 h0 = max(vec3(0), bias1[0] + vec3(
                    dot(w1[0], p[0]) + dot(w1[1], p[1]) + dot(w1[2], p[2]),
                    dot(w1[3], p[0]) + dot(w1[4], p[1]) + dot(w1[5], p[2]),
                    dot(w1[6], p[0]) + dot(w1[7], p[1]) + dot(w1[8], p[2])
                ));
                vec3 h1 = max(vec3(0), bias1[1] + vec3(
                    dot(w1[9], p[0]) + dot(w1[10], p[1]) + dot(w1[11], p[2]),
                    dot(w1[12], p[0]) + dot(w1[13], p[1]) + dot(w1[14], p[2]),
                    dot(w1[15], p[0]) + dot(w1[16], p[1]) + dot(w1[17], p[2])
                ));

                vec3 targetMass = vec3(
                    bias2.r + dot(w2[0], h0) + dot(w2[1], h1),
                    bias2.g + dot(w2[2], h0) + dot(w2[3], h1),
                    bias2.b + dot(w2[4], h0) + dot(w2[5], h1)
                );
                targetMass = clamp(targetMass, 0.0, 1.0);
                FOut = vec4(targetMass, 1.0);
            }
        `}, {
            size: cells[0].size,
            format: "rgba16f",
            tag: "targetMass",
        });

        cells = glsl({
            targetMass,
            seed: Math.random() * 12417,
            FP: `
            vec3 massTransfer(ivec2 pos, ivec2 dir) {
                pos = (pos + Src_size()) % Src_size();
                vec3 iWants = targetMass(pos).rgb - Src(pos).rgb;
                ivec2 dirPos = (pos + dir + Src_size()) % Src_size();
                vec3 dirWants = targetMass(dirPos).rgb - Src(dirPos).rgb;

                vec3 iMassClamped = clamp(Src(pos).rgb, 0.0, 1.0);
                vec3 dirMassClamped = clamp(Src(dirPos).rgb, 0.0, 1.0);

                vec3 maxDirAccept = (1.0 - dirMassClamped) / 8.0;
                vec3 minDirAccept = -dirMassClamped / 8.0;
                vec3 maxIAccept = (1.0 - iMassClamped) / 8.0;
                vec3 minIAccept = -iMassClamped / 8.0;

                vec3 giveDir = clamp(
                    (dirWants - iWants) / 32.0,
                    max(minDirAccept, -maxIAccept),
                    min(maxDirAccept, -minIAccept)
                );
                return giveDir;
            }

            void fragment() {
                FOut = Src(I);
                if (FOut.a == 0.0) {
                    FOut = vec4(hash(ivec3(I, seed)), 1);
                    return;
                }

                for (int k = 0; k < 9; k++) {
                    ivec2 offset = ivec2(k % 3 - 1, k / 3 - 1);
                    if (offset == ivec2(0)) { continue; }
                    FOut.rgb += (
                        massTransfer(I + offset, -offset)
                        - massTransfer(I, offset)
                    );
                }

                // TODO: fix evaporation
                FOut.rgb += vec3(0.00013);
            }
        `}, { ...cellsTargetParams });
    }

    function interact() {
        if (mouseIsPressed) {
            const aspect = windowWidth / windowHeight;
            const ww = windowWidth, wh = windowHeight;
            let mxSquare, mySquare;
            if (aspect > 1) {
                mxSquare = (ww / 2 + (mouseX - ww / 2) * aspect) / ww;
                mySquare = 1 - mouseY / wh;
            } else {
                mxSquare = mouseX / ww;
                mySquare = 1 - (wh / 2 + (mouseY - wh / 2) / aspect) / wh;
            }
            glsl({
                seed: Math.random() * 12417,
                mouseSquare: [mxSquare, mySquare],
                cells: cells[1],
                FP: `
                vec2 size = vec2(cells_size());
                float aspect = size.x / size.y;
                vec2 uvSquare = (
                    aspect > 1.0
                    ? vec2(0.5 + (UV.x - 0.5) * aspect, UV.y)
                    : vec2(UV.x, 0.5 + (UV.y - 0.5) / aspect)
                );
                if (distance(uvSquare, mouseSquare) < 0.1) {
                    FOut = vec4(hash(ivec3(I, seed)), 1);
                } else {
                    FOut = cells(I);
                }
            `}, cells[0]);
        }
    }

    function draw() {
        if (!pause) { step(); }
        interact();

        glsl({
            cells: cells[0],
            FP: "cells(UV)",
        });
    };

    function windowResized() {
        resizeCanvas(window.innerWidth, window.innerHeight);
    };
</script>

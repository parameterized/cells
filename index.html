<title>cells</title>
<link rel="icon" type="image/png" href="favicon.png" />
<style>
    html, body {
        padding: 0;
        margin: 0;
        overflow: hidden;
        background-color: #262626;
    }
    canvas { display: block; }

    .lil-gui { --width: 16em; }
</style>

<!-- fallback to cdn -->
<script src="lib/p5.js"></script>
<script>window.p5 || document.write('<script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.js">\x3C/script>')</script>
<script src="lib/swissgl.js"></script>
<script>window.SwissGL || document.write('<script src="https://cdn.jsdelivr.net/gh/google/swissgl@main/swissgl.js">\x3C/script>')</script>
<script src="lib/lil-gui.umd.js"></script>
<script>window.lil || document.write('<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.2/dist/lil-gui.umd.js">\x3C/script>')</script>

<!-- lil-gui icons will break if the below comment is removed -->
<!-- âœ“ -->
<!-- and gui init has to happen after body is created -->
<body>

<script>
const sauce = document.documentElement.innerHTML
const state = {}

const mouseButtonsDown = { 0: false, 1: false, 2: false }

state.paramsHistory = state.paramsHistory || []
state.historyIdx = state.historyIdx || 0

let canvas
let glsl, cells, targetMass

let frameCount = 0
let stepCount = 0
let lastCountsUpdate = 0
let stepTimer = 0

const guiButtons = {
    "new params": () => {
        state.paramsHistory.push(newParams())
        state.historyIdx = state.paramsHistory.length - 1
        guiButtons.reseed()
    },
    "last params": () => {
        if (state.historyIdx === 0) { return }
        state.historyIdx = max(state.historyIdx - 1, 0)
        if (state.guiParams["reseed on next/last params"]) {
            guiButtons.reseed()
        }
    },
    "next params": () => {
        if (state.historyIdx === state.paramsHistory.length - 1) { return }
        state.historyIdx = min(
            state.historyIdx + 1,
            state.paramsHistory.length - 1
        )
        if (state.guiParams["reseed on next/last params"]) {
            guiButtons.reseed()
        }
    },
    reseed: () => {
        glsl({ FP: "0" }, cells)
        step()
    },
    pause: () => {
        state.pause = !state.pause
    },
    step,
    "save as html": () => {
        const sauceWithState = sauce.replace(
            /(?<=const state = ).*/,
            `JSON.parse('${JSON.stringify(state)}')`
        )
        const a = document.createElement("a")
        const bob = new Blob([sauceWithState], {type: "text/plain"})
        a.setAttribute("href", URL.createObjectURL(bob))
        a.setAttribute("download", `${state.guiParams.filename}.html`)
        a.click()
    },
    "save as png": () => {
        const screenshotData = canvas.elt.toDataURL("image/png").replace(
            "image/png",
            "image/octet-stream"
        )
        const a = document.createElement("a")
        a.setAttribute("href", screenshotData)
        a.setAttribute("download", `${state.guiParams.filename}.png`)
        a.click()
    }
}

const gui = new lil.GUI()
gui.domElement.classList.add("force-touch-styles")
gui.domElement.onclick = e => {
    if (e.target.tagName === "DIV") {
        e.target.blur()
    }
}
gui.close()

for (const name in guiButtons) {
    gui.add(guiButtons, name)
}

state.guiParams = state.guiParams || {
    filename: `cells_${Math.random().toFixed(5).substr(2)}`,
    "reseed on next/last params": true,
    "mutation strength": 0.05,
    "pixels per cell": 6,
    gravity: 0,
    "solid vertical borders": false,
    "postprocess colors": false,
    tile: 2,
    "target steps/sec": 60,
    "brush size": 0.1,
}
gui.add(state.guiParams, "filename")
gui.add(state.guiParams, "reseed on next/last params")
gui.add(state.guiParams, "mutation strength", 0, 1, 0.001)
gui.add(state.guiParams, "pixels per cell", 1, 12, 0.1).onChange( value => {
    cellsTargetParams.scale = (
        1 / state.guiParams["pixels per cell"] / window.devicePixelRatio
    )
})
gui.add(state.guiParams, "gravity", -1, 1, 0.05)
gui.add(state.guiParams, "solid vertical borders")
gui.add(state.guiParams, "postprocess colors")
gui.add(state.guiParams, "tile", 1, 4, 1)
gui.add(state.guiParams, "target steps/sec", 30, 2000, 1)
const fpsController = gui.add({ "frames/sec": 0 }, "frames/sec").disable()
const spsController = gui.add({ "steps/sec": 0 }, "steps/sec").disable()
gui.add(state.guiParams, "brush size", 0.01, 0.5, 0.01)

gui.add({ "sorce": () => {
    const a = document.createElement("a")
    a.setAttribute("href", "https://github.com/parameterized/cells/blob/main/index.html")
    a.setAttribute("target", "_blank")
    a.click()
}}, "sorce")


gui.onChange(e => {
    for (const elt of [
        ...document.getElementsByTagName("button"),
        ...document.getElementsByTagName("input"),
    ]) {
        if (elt.type !== "text") {
            elt.blur()
        }
    }
})

const cellsTargetParams = {
    scale: 1 / state.guiParams["pixels per cell"] / window.devicePixelRatio,
    format: "rgba32f",
    story: 2,
    tag: "cells",
}

function setup() {
    canvas = createCanvas(windowWidth, windowHeight, WEBGL)
    glsl = SwissGL(canvas.elt)
    cells = glsl({
        seed: Math.random() * 12417,
        FP: "hash(ivec3(I, seed)), 1"
    }, { ...cellsTargetParams })

    if (!state.paramsHistory.length) {
        state.paramsHistory.push(newParams())
    }
    frameRate(60)

    addEventListener("contextmenu", e => {
        e.preventDefault()
    })

    setTimeout(() => {
        windowResized()
    }, 100)
}

function newParams() {
    const paramSets = {
        objects: [],
        encoded: [],
    }
    for (let k = 0; k < state.guiParams.tile**2; k++) {
        const w1 = [], bias1 = [], w2 = [], bias2 = []

        for (let i = 0; i < 9 * 6; i++) {
            w1.push(random(-1, 1))
        }
        for (let i = 0; i < 6; i++) {
            bias1.push(random())
        }
        for (let i = 0; i < 6 * 3; i++) {
            w2.push(random(-1, 1))
        }
        for (let i = 0; i < 3; i++) {
            bias2.push(random())
        }

        paramSets.objects.push({
            w1, bias1,
            w2, bias2,
        })
    }

    for (const params of paramSets.objects) {
        for (const name of [
            "w1", "bias1", "w2", "bias2"
        ]) {
            paramSets.encoded = paramSets.encoded.concat(params[name])
        }
    }

    return paramSets
}

function mutateParams(selectedParams) {
    const paramSets = {
        objects: [],
        encoded: [],
    }
    const sp = selectedParams
    const amt = state.guiParams["mutation strength"]
    for (let k = 0; k < state.guiParams.tile**2; k++) {
        const w1 = [], bias1 = [], w2 = [], bias2 = []

        for (let i = 0; i < 9 * 6; i++) {
            w1.push(
                min(max(
                    sp.w1[i] + random(-1, 1) * amt,
                -1), 1)
            )
        }
        for (let i = 0; i < 6; i++) {
            bias1.push(
                min(max(
                    sp.bias1[i] + random(-0.5, 0.5) * amt,
                0), 1)
            )
        }
        for (let i = 0; i < 6 * 3; i++) {
            w2.push(
                min(max(
                    sp.w2[i] + random(-1, 1) * amt,
                -1), 1)
            )
        }
        for (let i = 0; i < 3; i++) {
            bias2.push(
                min(max(
                    sp.bias2[i] + random(-0.5, 0.5) * amt,
                0), 1)
            )
        }

        paramSets.objects.push({
            w1, bias1,
            w2, bias2,
        })
    }

    for (const params of paramSets.objects) {
        for (const name of [
            "w1", "bias1", "w2", "bias2"
        ]) {
            paramSets.encoded = paramSets.encoded.concat(params[name])
        }
    }

    return paramSets
}

function mousePressed(e) {
    if (e.target !== canvas.elt) { return }
    if (e.detail > 1) {
        e.preventDefault()
    }
    if (e.button in mouseButtonsDown) {
        mouseButtonsDown[e.button] = true
    }

    if (e.button === 2) {
        const tile = state.guiParams.tile
        const tileX = min(max(int(mouseX / windowWidth * tile), 0), tile - 1)
        const tileY = min(max(int(mouseY / windowHeight * tile), 0), tile - 1)
        const tileIdx = tileY * tile + tileX
        const selectedParams = (
            state.paramsHistory[state.historyIdx].objects[tileIdx]
        )
        state.paramsHistory.push(mutateParams(selectedParams))
        state.historyIdx = state.paramsHistory.length - 1
        guiButtons.reseed()
    }
}

function mouseReleased(e) {
    if (e.button in mouseButtonsDown) {
        mouseButtonsDown[e.button] = false
    }
}

// better version of mouseIsPressed
function mouseIsDown(button) {
    if (button === undefined) {
        for (const b in mouseButtonsDown) {
            if (mouseButtonsDown[b]) {
                return true
            }
        }
        return false
    }
    return button in mouseButtonsDown && mouseButtonsDown[button]
}

function keyPressed(e) {
    if (key === "f") {
        guiButtons["new params"]()
    } else if (key === "ArrowLeft") {
        guiButtons["last params"]()
    } else if (key === "ArrowRight") {
        guiButtons["next params"]()
    } else if (key === "r") {
        guiButtons.reseed()
    } else if (key === " ") {
        guiButtons.pause()
    } else if (key === "s") {
        guiButtons.step()
    } else if (key === "Backspace") {
        e.preventDefault()
    }
}

function step() {
    targetMass = glsl({
        cells: cells[0],
        p: state.paramsHistory[state.historyIdx].encoded,
        tile: state.guiParams.tile,
        FP: `
        uniform vec3 p[${27 * state.guiParams.tile**2}];
        uniform int tile;
        
        mat3 sobelX = mat3( 
            1.0, 2.0, 1.0, 
            0.0, 0.0, 0.0, 
           -1.0, -2.0, -1.0 
        );
        mat3 sobelY = mat3( 
            1.0, 0.0, -1.0, 
            2.0, 0.0, -2.0, 
            1.0, 0.0, -1.0 
        );

        void fragment() {
            int paramGridX = min(max(int(UV.x * float(tile)), 0), tile - 1);
            int paramGridY = min(max(int(UV.y * float(tile)), 0), tile - 1);
            int o = ((tile - 1 - paramGridY) * tile + paramGridX) * 27;

            vec3 w1[18] = vec3[](
                p[o+0], p[o+1], p[o+2], p[o+3], p[o+4], p[o+5],
                p[o+6], p[o+7], p[o+8], p[o+9], p[o+10], p[o+11],
                p[o+12], p[o+13], p[o+14], p[o+15], p[o+16], p[o+17]
            );
            vec3 bias1[2] = vec3[](p[o+18], p[o+19]);
            vec3 w2[6] = vec3[](
                p[o+20], p[o+21], p[o+22], p[o+23], p[o+24], p[o+25]
            );
            vec3 bias2 = p[o+26];

            float angle = 0.0;
            float cosa = cos(angle);
            float sina = sin(angle);
            mat3 sx = cosa * sobelX - sina * sobelY;
            mat3 sy = sina * sobelX + cosa * sobelY;

            ivec2 cs = cells_size();
            vec4 rgb00 = cells((I + ivec2(-1, 1) + cs) % cs);
            vec4 rgb01 = cells((I + ivec2(-0, 1) + cs) % cs);
            vec4 rgb02 = cells((I + ivec2(1, 1) + cs) % cs);
            vec4 rgb10 = cells((I + ivec2(-1, 0) + cs) % cs);
            vec4 rgb11 = cells((I + ivec2(-0, 0) + cs) % cs);
            vec4 rgb12 = cells((I + ivec2(1, 0) + cs) % cs);
            vec4 rgb20 = cells((I + ivec2(-1, -1) + cs) % cs);
            vec4 rgb21 = cells((I + ivec2(-0, -1) + cs) % cs);
            vec4 rgb22 = cells((I + ivec2(1, -1) + cs) % cs);
            mat3 ares = mat3(
                rgb00.r, rgb01.r, rgb02.r,
                rgb10.r, rgb11.r, rgb12.r,
                rgb20.r, rgb21.r, rgb22.r
            );
            mat3 gees = mat3(
                rgb00.g, rgb01.g, rgb02.g,
                rgb10.g, rgb11.g, rgb12.g,
                rgb20.g, rgb21.g, rgb22.g
            );
            mat3 bees = mat3(
                rgb00.b, rgb01.b, rgb02.b,
                rgb10.b, rgb11.b, rgb12.b,
                rgb20.b, rgb21.b, rgb22.b
            );

            vec3 perceptSelf = rgb11.rgb;
            vec3 perceptSX = vec3(
                dot(sx[0], ares[0]) + dot(sx[1], ares[1]) + dot(sx[2], ares[2]),
                dot(sx[0], gees[0]) + dot(sx[1], gees[1]) + dot(sx[2], gees[2]),
                dot(sx[0], bees[0]) + dot(sx[1], bees[1]) + dot(sx[2], bees[2])
            );
            vec3 perceptSY = vec3(
                dot(sy[0], ares[0]) + dot(sy[1], ares[1]) + dot(sy[2], ares[2]),
                dot(sy[0], gees[0]) + dot(sy[1], gees[1]) + dot(sy[2], gees[2]),
                dot(sy[0], bees[0]) + dot(sy[1], bees[1]) + dot(sy[2], bees[2])
            );

            mat3 per = mat3(
                perceptSelf,
                perceptSX,
                perceptSY
            );

            vec3 h0 = max(vec3(0), bias1[0] + vec3(
                dot(w1[0], per[0]) + dot(w1[1], per[1]) + dot(w1[2], per[2]),
                dot(w1[3], per[0]) + dot(w1[4], per[1]) + dot(w1[5], per[2]),
                dot(w1[6], per[0]) + dot(w1[7], per[1]) + dot(w1[8], per[2])
            ));
            vec3 h1 = max(vec3(0), bias1[1] + vec3(
                dot(w1[9], per[0]) + dot(w1[10], per[1]) + dot(w1[11], per[2]),
                dot(w1[12], per[0]) + dot(w1[13], per[1]) + dot(w1[14], per[2]),
                dot(w1[15], per[0]) + dot(w1[16], per[1]) + dot(w1[17], per[2])
            ));

            vec3 targetMass = vec3(
                bias2.r + dot(w2[0], h0) + dot(w2[1], h1),
                bias2.g + dot(w2[2], h0) + dot(w2[3], h1),
                bias2.b + dot(w2[4], h0) + dot(w2[5], h1)
            );
            targetMass = clamp(targetMass, 0.0, 1.0);
            FOut = vec4(targetMass, 1.0);
        }
    `}, {
        size: cells[0].size,
        format: "rgba32f",
        tag: "targetMass",
    })

    cells = glsl({
        targetMass,
        seed: Math.random() * 12417,
        gravity: state.guiParams.gravity,
        solidVerticalBorders: state.guiParams["solid vertical borders"],
        tile: state.guiParams.tile,
        FP: `
        vec3 massTransfer(ivec2 pos, ivec2 dir) {
            pos = (pos + Src_size()) % Src_size();
            ivec2 dirPos = (pos + dir + Src_size()) % Src_size();

            vec2 posUV = (vec2(pos) + vec2(0.5)) / vec2(targetMass_size());
            vec2 dirUV = (vec2(dirPos) + vec2(0.5)) / vec2(targetMass_size());
            int gridY = int(floor(posUV.y * tile));
            int gridYDir = int(floor(dirUV.y * tile));
            if (solidVerticalBorders && gridYDir != gridY) {
                return vec3(0);
            }

            vec3 iWants = targetMass(pos).rgb - Src(pos).rgb;
            vec3 dirWants = targetMass(dirPos).rgb - Src(dirPos).rgb;

            vec3 iMassClamped = clamp(Src(pos).rgb, 0.0, 1.0);
            vec3 dirMassClamped = clamp(Src(dirPos).rgb, 0.0, 1.0);

            vec3 maxDirAccept = (1.0 - dirMassClamped) / 8.0;
            vec3 minDirAccept = -dirMassClamped / 8.0;
            vec3 maxIAccept = (1.0 - iMassClamped) / 8.0;
            vec3 minIAccept = -iMassClamped / 8.0;

            vec3 gravGiveDir = mix(
                max(minDirAccept, -maxIAccept),
                min(maxDirAccept, -minIAccept),
                -gravity * float(dir.y) * 0.5 + 0.5
            );
            vec3 targetGiveDir = clamp(
                (dirWants - iWants) / 32.0,
                max(minDirAccept, -maxIAccept),
                min(maxDirAccept, -minIAccept)
            );
            float mass = mix(
                dot(targetMass(pos).rgb, vec3(1.0 / 3.0)),
                dot(targetMass(dirPos).rgb, vec3(1.0 / 3.0)),
                0.5
            );
            vec3 giveDir = mix(
                targetGiveDir,
                gravGiveDir,
                (1.0 - abs(float(dir.x))) * (1.0 - mass) * abs(gravity)
            );

            return giveDir;
        }

        void fragment() {
            FOut = Src(I);
            if (FOut.a == 0.0) {
                FOut = vec4(hash(ivec3(I, seed)), 1);
                return;
            }

            for (int k = 0; k < 9; k++) {
                ivec2 offset = ivec2(k % 3 - 1, k / 3 - 1);
                if (offset == ivec2(0)) { continue; }
                FOut.rgb += (
                    massTransfer(I + offset, -offset)
                    - massTransfer(I, offset)
                );
            }
        }
    `}, { ...cellsTargetParams })
}

function interact() {
    if (mouseIsDown(0)) {
        const aspect = windowWidth / windowHeight
        const ww = windowWidth, wh = windowHeight
        let mxSquare, mySquare
        if (aspect > 1) {
            mxSquare = (ww / 2 + (mouseX - ww / 2) * aspect) / ww
            mySquare = 1 - mouseY / wh
        } else {
            mxSquare = mouseX / ww
            mySquare = 1 - (wh / 2 + (mouseY - wh / 2) / aspect) / wh
        }
        glsl({
            seed: Math.random() * 12417,
            mouseSquare: [mxSquare, mySquare],
            brushSize: state.guiParams["brush size"],
            cells: cells[1],
            FP: `
            vec2 size = vec2(cells_size());
            float aspect = size.x / size.y;
            vec2 uvSquare = (
                aspect > 1.0
                ? vec2(0.5 + (UV.x - 0.5) * aspect, UV.y)
                : vec2(UV.x, 0.5 + (UV.y - 0.5) / aspect)
            );
            if (distance(uvSquare, mouseSquare) < brushSize) {
                FOut = vec4(hash(ivec3(I, seed)), 1);
            } else {
                FOut = cells(I);
            }
        `}, cells[0])
    }
}

function draw() {
    stepTimer = max(stepTimer - deltaTime, -1000 / 30)
    const startMillis = millis()
    while (
        !state.pause
        && stepTimer < 0
        && millis() - startMillis < 1000 / 30
    ) {
        step()
        stepCount++
        stepTimer += 1000 / state.guiParams["target steps/sec"]
    }
    interact()

    if (state.guiParams["postprocess colors"]) {
        glsl({
            cells: cells[0],
            FP: `
            vec3 color = cells(UV).rgb;
            vec3 colorMinusWhite = (color - vec3(1));
            vec3 colorMWNorm = normalize(colorMinusWhite);
            float colorMWLen = length(colorMinusWhite);
            float newLen = 1.2 + 0.7 * tanh(colorMWLen - 1.0);
            FOut = vec4(vec3(1) + colorMWNorm * newLen, 1);
        `})
    } else {
        glsl({
            cells: cells[0],
            FP: "cells(UV)",
        })

        // let a = atan2(mouseY - windowHeight / 2, mouseX - windowWidth / 2)
        // console.log(a);
        // glsl({
        //     a,
        //     FP: `
        //     mat3 sx = mat3( 
        //         1.0, 2.0, 1.0, 
        //         0.0, 0.0, 0.0, 
        //        -1.0, -2.0, -1.0 
        //     );
        //     mat3 sy = mat3( 
        //         1.0, 0.0, -1.0, 
        //         2.0, 0.0, -2.0, 
        //         1.0, 0.0, -1.0 
        //     );
        //     float c = cos(a);
        //     float s = sin(a);
        //     mat3 sxr = c * sx - s * sy;
        //     mat3 syr = s * sx + c * sy;

        //     int tile_x = int(UV.x * 3.0);
        //     int tile_y = int((1.0-UV.y) * 3.0);
        //     float v = syr[tile_y][tile_x];
        //     FOut = vec4(vec3(v / 4.0 + 0.5), 1);
        //     `
        // })
    }

    frameCount++
    if (millis() - lastCountsUpdate >= 1000) {
        lastCountsUpdate = millis()
        fpsController.setValue(frameCount)
        spsController.setValue(stepCount)
        frameCount = 0
        stepCount = 0
    }
}

function windowResized() {
    resizeCanvas(window.innerWidth, window.innerHeight)
}

</script>

<!DOCTYPE html>
<html>
<head>
<title>mfm</title>
<link rel="icon" type="image/png" href="img/SelfImage.png" />
</head>
<body style="margin: 0; overflow: hidden; background-color: #222">
<canvas style="display: block"></canvas>

<script id="main">
const grid_size = 256

onload = function() {
    load_webgl()
    loop()
}

function loop() {
    fix_size()
    update_cam()

    if (mouse_held(0)) {
        interact()
    }

    if (!paused) sim_step()
    draw()

    mouse.px = mouse.x
    mouse.py = mouse.y

    requestAnimationFrame(loop)
}
</script>


<script id="controls">
let paused = false
const mouse = {
    x: 0, y: 0,
    px: 0, py: 0,
    held: { 0: false, 1: false, 2: false },
}

function mouse_held(button) {
    if (button === undefined) {
        for (const b in mouse.held) {
            if (mouse.held[b]) {
                return true
            }
        }
        return false
    }
    return button in mouse.held && mouse.held[button]
}

onmousemove = e => {
    mouse.x = e.x
    mouse.y = e.y
}
onwheel = e => {
    zoom.vel_factor -= e.deltaY / 2000   
}
oncontextmenu = e => e.preventDefault()
onmousedown = e => {
    if (e.button in mouse.held) {
        mouse.held[e.button] = true
    }
    if (e.button === 2) {
        pan.held = true
    }
}
onmouseup = e => {
    if (e.button in mouse.held) {
        mouse.held[e.button] = false
    }
    if (e.button === 2) {
        pan.held = false
    }
}
onmouseleave = e => {
    pan.held = false
}

onkeydown = e => {
    if (e.key === " ") {
        paused = !paused
    } else if (e.key === "ArrowRight") {
        sim_step()
    } else if (e.key === "f") {
        do_fix = !do_fix
    }
}
</script>


<script id="camera">
const pan = {
    x: 0, y: 0,
    xv: 0, yv: 0,
    held: false,
}
const zoom = {
    scale: 1,
    min_scale: 1,
    max_scale: 20,
    vel_factor: 1,
}

function update_cam() {
    // zoom
    const pscale1 = zoom.scale
    zoom.vel_factor = clamp(zoom.vel_factor, 0.5, 2.0)
    zoom.scale *= zoom.vel_factor
    const pscale2 = zoom.scale
    // elastic bounds
    const log_zoom = log2(zoom.scale)
    const log_min = log2(zoom.min_scale)
    const log_max = log2(zoom.max_scale)
    const log_target = log_zoom < log_min ? log_min : (
        log_zoom > log_max ? log_max : log_zoom
    )
    const bounce_factor = 1 - pow(
        1.7,
        -pow(abs(log_zoom - log_target) * 0.5, 0.5),
    )
    zoom.scale = pow(2, lerp(log_zoom, log_target, bounce_factor))
    zoom.vel_factor = lerp(
        zoom.vel_factor, 1, 0.2 * pow(3, -bounce_factor * 2)
    )

    // update pan to keep mouse in place
    // (or more slidey for elastic scaling)
    const short_edge = min(innerWidth, innerHeight)
    const mouse_uv = [
        (mouse.x - innerWidth / 2) / short_edge,
        (mouse.y - innerHeight / 2) / short_edge,
    ]
    const pan_factor = 1 / pscale1 - 1 / zoom.scale

    if (zoom.scale > zoom.min_scale && zoom.scale < zoom.max_scale) {
        pan.x -= mouse_uv[0] * pan_factor
        pan.y -= mouse_uv[1] * pan_factor
    } else if (
        zoom.scale < zoom.min_scale && pan_factor <= 0
        || zoom.scale > zoom.min_scale && pan_factor >= 0
    ) {
        const pan_factor_scroll = 1 / pscale1 - 1 / pscale2
        const a = 0.2
        // it just works tm
        const f = pan_factor + a * exp(
            (pan_factor_scroll - pan_factor) / a
        ) - a
        const cur_d = pow(pan.xv, 2) + pow(pan.yv, 2)
        const prop_d = (
            pow(mouse_uv[0] * f, 2)
            + pow(mouse_uv[1] * f, 2)
        )
        if (prop_d > cur_d) {
            pan.xv = -mouse_uv[0] * f
            pan.yv = -mouse_uv[1] * f
        }
    }

    // pan
    // todo: framerate independence, mouse velocity smoothing
    if (pan.held) {
        const dx = (mouse.x - mouse.px) / zoom.scale / short_edge
        const dy = (mouse.y - mouse.py) / zoom.scale / short_edge
        pan.xv = dx
        pan.yv = dy
        pan.x += dx
        pan.y += dy
    } else {
        pan.x += pan.xv
        pan.y += pan.yv
        pan.xv *= 0.9
        pan.yv *= 0.9
    }
}

const log2 = Math.log2
const exp = Math.exp
const pow = Math.pow
const abs = Math.abs
const min = Math.min
const max = Math.max
function clamp(x, a, b) {
    return min(max(x, a), b)
}
function lerp(a, b, t) {
    return a * (1 - t) + b * t
}
function inv_lerp(a, b, x) {
    if (b - a === 0) return 0 
    return (x - a) / (b - a)
}
function mod(x, n) {
    return ((x % n) + n) % n
}
</script>


<script type="x-shader/x-vertex" id="vert">
#version 300 es
in vec2 pos;
out vec2 uv;

void main() {
    gl_Position = vec4(pos, 0, 1);
    uv = pos * 0.5 + 0.5;
}
</script>


<script type="x-shader/x-fragment" id="frag_sim">
#version 300 es
precision highp float;
precision highp int;

out float cell;

uniform sampler2D cells;
uniform int time_step;

vec3 hash(ivec3 ix) {
    // source: https://www.shadertoy.com/view/XlXcW4
    uvec3 x = uvec3(ix);
    const uint k = 1103515245U;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    return vec3(x) * (1.0 / float(0xffffffffU));
}

void main() {
    ivec2 p = ivec2(gl_FragCoord.xy);

    // cycle through 2-cell event window grid alignments & phases
    // note: has some directional bias
    ivec2 dir = bool(time_step % 2) ? ivec2(1, 0) : ivec2(0, 1);
    int grid_phase = (time_step / 2) % 2;
    int cell_phase = ((p.x * dir.x + p.y * dir.y) + grid_phase) % 2;
    ivec2 window_p = p - cell_phase * dir;

    vec3 rng = hash(ivec3(window_p, time_step));
    bool swap = rng.g < 0.5;
    if (swap) {
        vec2 res = vec2(textureSize(cells, 0));
        float other_cell = texture(
            cells,
            vec2(window_p + dir * (1 - cell_phase)) / res
        ).r;
        cell = other_cell;
    } else {
        cell = min(
            texelFetch(cells, p, 0).r + 0.005,
            0.8 + rng.b * 0.2
        );
    }
}
</script>


<script type="x-shader/x-fragment" id="frag_interact">
#version 300 es
precision mediump float;
out float cell;

uniform sampler2D cells;
uniform int time_step;
uniform vec2 mouse;
uniform float brush_size;

vec3 hash(ivec3 ix) {
    // source: https://www.shadertoy.com/view/XlXcW4
    uvec3 x = uvec3(ix);
    const uint k = 1103515245U;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    return vec3(x) * (1.0 / float(0xffffffffU));
}

void main() {
    ivec2 p = ivec2(gl_FragCoord.xy);
    vec2 size = vec2(textureSize(cells, 0));
    vec2 uv = vec2(p) / size;

    for (int i = -1; i <= 1; ++i) {
        for (int j = -1; j <= 1; ++j) {
            vec2 uv_tile = uv + vec2(i, j);
            if (distance(uv_tile, mouse) < brush_size) {
                cell = hash(ivec3(p, time_step)).r / 2.0;
                return;
            }
        }
    }
    cell = texelFetch(cells, p, 0).r;
}
</script>


<script type="x-shader/x-fragment" id="frag_draw">
#version 300 es
precision mediump float;
in vec2 uv;
out vec4 color;

uniform sampler2D cells;
uniform sampler2D font;

uniform vec2 screen_size;
uniform float zoom_scale;
uniform vec2 offset;
uniform int time_step;
uniform bool do_fix;

vec3 hash(ivec3 ix) {
    // source: https://www.shadertoy.com/view/XlXcW4
    uvec3 x = uvec3(ix);
    const uint k = 1103515245U;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    return vec3(x) * (1.0 / float(0xffffffffU));
}

int sum(ivec2 x) {
    return x.x + x.y;
}
int sum(ivec3 x) {
    return x.x + x.y + x.z;
}

int floor_div(int x, int k) {
    return x < 0 ? -((abs(x) - 1) / k) - 1 : x / k;
}
ivec2 floor_div(ivec2 x, int k) {
    return ivec2(floor_div(x.x, k), floor_div(x.y, k));
}

int ceil_div(int x, int k) {
    return x / k + int(x % k != 0 && (x < 0) == (k < 0));
}

ivec2 modi(ivec2 x, int k) {
    return x - floor_div(x, k) * k;
}

float get_font(int id, vec4 box, vec2 p) {
    vec2 box_uv = clamp((p - box.xy) / box.zw, 0.0, 1.0);
    vec2 char_uv = (box_uv + vec2(float(id), 0.0)) / vec2(10.0, 1.0);
    char_uv.y = 1.0 - char_uv.y;
    return texture(font, char_uv).a;
}

ivec4 get_ew_coords(ivec2 p) {
    // returns: (x, y, distance, id)

    // related to poisson disk sampling and blue noise

    // cells have probability x of being candidate ew centers
    // if any two would overlap (distance <= 8), both are invalid
    // 145 cells in a manhattan distance 8 window
    // P(ew center) = x * (1 - x)^144
    // max is 0.0025 at x = 1 / 145 = 0.0069

    // approximate with 12x12 cell tiles proposing 0 or 1 candidates
    // can look at neighboring 8 tiles to determine validity
    // (of md4 event windows that overlap with this cell's tile)
    // P(tile has candidate) = 1 - (1 - x)^144 = 0.6308
    // (optimal rate would be a bit higher with 0 or 1 approximation)

    // todo: test different proposal rates,
    // try 2nd proposal pass to increase density

    // get (x, y, proposal rng) for tile and neighbors
    ivec3 o = ivec3(-1, 0, 1);
    ivec2 tile = floor_div(p, 12);
    vec3 r00 = hash(ivec3(tile + o.xx, time_step));
    vec3 r01 = hash(ivec3(tile + o.xy, time_step));
    vec3 r02 = hash(ivec3(tile + o.xz, time_step));
    vec3 r10 = hash(ivec3(tile + o.yx, time_step));
    vec3 r11 = hash(ivec3(tile + o.yy, time_step));
    vec3 r12 = hash(ivec3(tile + o.yz, time_step));
    vec3 r20 = hash(ivec3(tile + o.zx, time_step));
    vec3 r21 = hash(ivec3(tile + o.zy, time_step));
    vec3 r22 = hash(ivec3(tile + o.zz, time_step));

    // convert x, y to center tile relative cell coords
    // or "throw it away" if it "wasnt actually proposed"
    ivec2 invalid = o.zz * 99;
    ivec2 p00 = (
        r00.z < 0.6308 ? o.xx * 12 + ivec2(r00.xy * 12.0) : invalid
    );
    ivec2 p01 = (
        r01.z < 0.6308 ? o.xy * 12 + ivec2(r01.xy * 12.0) : invalid
    );
    ivec2 p02 = (
        r02.z < 0.6308 ? o.xz * 12 + ivec2(r02.xy * 12.0) : invalid
    );
    ivec2 p10 = (
        r10.z < 0.6308 ? o.yx * 12 + ivec2(r10.xy * 12.0) : invalid
    );
    ivec2 p11 = (
        r11.z < 0.6308 ? o.yy * 12 + ivec2(r11.xy * 12.0) : invalid
    );
    ivec2 p12 = (
        r12.z < 0.6308 ? o.yz * 12 + ivec2(r12.xy * 12.0) : invalid
    );
    ivec2 p20 = (
        r20.z < 0.6308 ? o.zx * 12 + ivec2(r20.xy * 12.0) : invalid
    );
    ivec2 p21 = (
        r21.z < 0.6308 ? o.zy * 12 + ivec2(r21.xy * 12.0) : invalid
    );
    ivec2 p22 = (
        r22.z < 0.6308 ? o.zz * 12 + ivec2(r22.xy * 12.0) : invalid
    );

    // also throw away overlaps

    bool sep_00_01 = sum(abs(p00 - p01)) > 8;
    bool sep_00_10 = sum(abs(p00 - p10)) > 8;
    bool sep_00_11 = sum(abs(p00 - p11)) > 8;

    bool sep_01_02 = sum(abs(p01 - p02)) > 8;
    bool sep_01_10 = sum(abs(p01 - p10)) > 8;
    bool sep_01_11 = sum(abs(p01 - p11)) > 8;
    bool sep_01_12 = sum(abs(p01 - p12)) > 8;

    bool sep_02_11 = sum(abs(p02 - p11)) > 8;
    bool sep_02_12 = sum(abs(p02 - p12)) > 8;

    bool sep_10_11 = sum(abs(p10 - p11)) > 8;
    bool sep_10_20 = sum(abs(p10 - p20)) > 8;
    bool sep_10_21 = sum(abs(p10 - p21)) > 8;

    bool sep_11_12 = sum(abs(p11 - p12)) > 8;
    bool sep_11_20 = sum(abs(p11 - p20)) > 8;
    bool sep_11_21 = sum(abs(p11 - p21)) > 8;
    bool sep_11_22 = sum(abs(p11 - p22)) > 8;

    bool sep_12_21 = sum(abs(p12 - p21)) > 8;
    bool sep_12_22 = sum(abs(p12 - p22)) > 8;

    bool sep_20_21 = sum(abs(p20 - p21)) > 8;

    bool sep_21_22 = sum(abs(p21 - p22)) > 8;

    if (do_fix)
    {
    p00 = sep_00_01 && sep_00_10 && sep_00_11 ? p00 : invalid;
    p01 = (
        sep_00_01 && sep_01_02 && sep_01_10 && sep_01_11 && sep_01_12
    ) ? p01 : invalid;
    p02 = sep_01_02 && sep_02_11 && sep_02_12 ? p02 : invalid;
    p10 = (
        sep_00_10 && sep_01_10 && sep_10_11 && sep_10_20 && sep_10_21
    ) ? p10 : invalid;
    p11 = (
        sep_00_11 && sep_01_11 && sep_02_11 && sep_10_11
        && sep_11_12 && sep_11_20 && sep_11_21 && sep_11_22
    ) ? p11 : invalid;
    p12 = (
        sep_01_12 && sep_02_12 && sep_11_12 && sep_12_21 && sep_12_22
    ) ? p12 : invalid;
    p20 = sep_10_20 && sep_11_20 && sep_20_21 ? p20 : invalid;
    p21 = (
        sep_10_21 && sep_11_21 && sep_12_21 && sep_20_21 && sep_21_22
    ) ? p21 : invalid;
    p22 = sep_11_22 && sep_12_22 && sep_21_22 ? p22 : invalid;
    }

    // get cell position relative to closest event window

    ivec2 p_rel_tile = modi(p, 12);

    // position relative to each possible window
    ivec3 pr_00 = ivec3(p_rel_tile - p00, 0);
    ivec3 pr_01 = ivec3(p_rel_tile - p01, 0);
    ivec3 pr_02 = ivec3(p_rel_tile - p02, 0);
    ivec3 pr_10 = ivec3(p_rel_tile - p10, 0);
    ivec3 pr_11 = ivec3(p_rel_tile - p11, 0);
    ivec3 pr_12 = ivec3(p_rel_tile - p12, 0);
    ivec3 pr_20 = ivec3(p_rel_tile - p20, 0);
    ivec3 pr_21 = ivec3(p_rel_tile - p21, 0);
    ivec3 pr_22 = ivec3(p_rel_tile - p22, 0);

    // add manhattan distances
    pr_00.z = sum(abs(pr_00.xy));
    pr_01.z = sum(abs(pr_01.xy));
    pr_02.z = sum(abs(pr_02.xy));
    pr_10.z = sum(abs(pr_10.xy));
    pr_11.z = sum(abs(pr_11.xy));
    pr_12.z = sum(abs(pr_12.xy));
    pr_20.z = sum(abs(pr_20.xy));
    pr_21.z = sum(abs(pr_21.xy));
    pr_22.z = sum(abs(pr_22.xy));

    // reduce to closest

    ivec3 pr_0_1 = pr_00.z < pr_01.z ? pr_00 : pr_01;
    ivec3 pr_2_3 = pr_02.z < pr_10.z ? pr_02 : pr_10;
    ivec3 pr_4_5 = pr_11.z < pr_12.z ? pr_11 : pr_12;
    ivec3 pr_6_7 = pr_20.z < pr_21.z ? pr_20 : pr_21;

    ivec3 pr_0_3 = pr_0_1.z < pr_2_3.z ? pr_0_1 : pr_2_3;
    ivec3 pr_4_7 = pr_4_5.z < pr_6_7.z ? pr_4_5 : pr_6_7;

    ivec3 pr_0_7 = pr_0_3.z < pr_4_7.z ? pr_0_3 : pr_4_7;
    ivec4 p_rel_ew = ivec4(pr_0_7.z < pr_22.z ? pr_0_7 : pr_22, 0);

    // add id

    // todo: invert y earlier
    p_rel_ew.y = -p_rel_ew.y;

    ivec3 offsets = ivec3(0);
    int x = p_rel_ew.x;
    int y = p_rel_ew.y;
    int md = p_rel_ew.z;
    int mag = max(abs(x), abs(y));

    offsets.x = 2 * md * (md - 1) + int(md > 0);
    if (mag > 1) {
        int min_mag = ceil_div(md, 2);
        int phase = ((md + 1) % 2) * 4;
        offsets.y = max((mag - min_mag) * 8 - phase, 0);
    }
    offsets.z = md == 0 ? 0 : (
        md == mag ? (x + md) / md + int(x + y > 0)
        : x < 0 ? 2 * int(md + x > -x) + int(y > 0)
        : abs(x) == abs(y) ? 2 + int(y > 0)
        : 4 + 2 * int(md - x < x) + int(y > 0)
    );
    p_rel_ew.w = sum(offsets);

    return p_rel_ew;
}

vec4 ew_colors[] = vec4[](
    vec4(250.0, 250.0, 242.0, 255.0) / 255.0,
    vec4(247.0, 253.0, 245.0, 255.0) / 255.0,
    vec4(235.0, 254.0, 253.0, 255.0) / 255.0,
    vec4(217.0, 241.0, 253.0, 255.0) / 255.0,
    vec4(250.0, 217.0, 217.0, 255.0) / 255.0,
    vec4(229.0, 230.0, 230.0, 255.0) / 255.0
);

vec4 get_ew_color(vec2 p) {
    vec4 color = vec4(0.0);
    ivec4 ew_coords = get_ew_coords(ivec2(floor(p)));
    int d = ew_coords.z;
    int id = ew_coords.w;
    if (d <= 5) {
        color = ew_colors[d];
    }
    if (d <= 4) {
        float num_visibility = smoothstep(
            1.0, log2(16.0), log2(zoom_scale)
        );
        float num_alpha = 0.0;
        vec2 cell_uv = mod(p, 1.0);
        if (id < 10) {
            num_alpha = get_font(
                id, vec4(0.35, 0.35, 0.3, 0.3), cell_uv
            );
        } else {
            num_alpha = max(
                get_font(
                    id / 10, vec4(0.2, 0.35, 0.3, 0.3), cell_uv
                ),
                get_font(
                    id % 10, vec4(0.5, 0.35, 0.3, 0.3), cell_uv
                )
            );
        }
        color = mix(
            color,
            vec4(vec3(0.0), 1.0),
            num_alpha * num_visibility
        );
    }
    return color;
}

vec2 get_cam_uv() {
    vec2 ss = screen_size;
    vec2 aspect_scale = ss / min(ss.x, ss.y);
    return 0.5 + (uv - 0.5) * aspect_scale / zoom_scale + offset;
}

void main() {
    vec2 cam_uv = get_cam_uv();
    float value = texture(cells, cam_uv).r;

    // numbers
    float num_visibility = smoothstep(
        1.0, log2(16.0), log2(zoom_scale)
    );
    vec2 cs = vec2(textureSize(cells, 0));
    vec2 cell_uv = mod(cam_uv * cs, vec2(1.0));
    float num_alpha = get_font(
        int(value * 9.0 + 0.5),
        vec4(0.25, 0.25, 0.5, 0.5),
        cell_uv
    );
    value = mix(
        value, mod(value + 0.5, 1.0), num_alpha * num_visibility
    );

    color = vec4(vec3(value), 1.0);

    vec4 ew_color = get_ew_color(cam_uv * cs);
    color.rgb = mix(color.rgb, ew_color.rgb, ew_color.a);
}
</script>


<script id="webgl_loop">
let time_step = 0

function fix_size() {
    if (
        canvas.width !== innerWidth
        || canvas.height !== innerHeight
    ) {
        canvas.width = innerWidth
        canvas.height = innerHeight
    }
    gl.viewport(0, 0, canvas.width, canvas.height)
}

function sim_step() {
    gl.useProgram(sim_program)
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb)
    gl.framebufferTexture2D(
        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
        grid_cells[1], 0,
    )
    gl.bindTexture(gl.TEXTURE_2D, grid_cells[0])
    gl.uniform1i(
        gl.getUniformLocation(sim_program, "time_step"),
        time_step,
    )
    gl.enableVertexAttribArray(0)
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0)
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
    grid_cells = [grid_cells[1], grid_cells[0]]
    time_step++
}

function interact() {
    // get mouse cam coords
    const short_edge = min(innerWidth, innerHeight)
    const scale = short_edge * zoom.scale
    const mx = mod(
        0.5 + (mouse.x - innerWidth / 2) / scale - pan.x,
        1,
    )
    const my = mod(
        0.5 - (mouse.y - innerHeight / 2) / scale + pan.y,
        1,
    )

    // bloatware for the draw call
    gl.useProgram(interact_program)
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb)
    gl.framebufferTexture2D(
        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
        grid_cells[1], 0,
    )
    gl.activeTexture(gl.TEXTURE0)
    gl.bindTexture(gl.TEXTURE_2D, grid_cells[0])
    gl.uniform1i(
        gl.getUniformLocation(interact_program, "time_step"),
        time_step,
    )
    gl.uniform2f(
        gl.getUniformLocation(interact_program, "mouse"),
        mx, my,
    )
    gl.uniform1f(
        gl.getUniformLocation(interact_program, "brush_size"),
        0.05 / zoom.scale,
    )
    gl.enableVertexAttribArray(0)
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0)
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
    grid_cells = [grid_cells[1], grid_cells[0]]
}

function draw() {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null)
    gl.useProgram(draw_program)

    gl.activeTexture(gl.TEXTURE0)
    gl.bindTexture(gl.TEXTURE_2D, grid_cells[0])
    gl.activeTexture(gl.TEXTURE1)
    gl.bindTexture(gl.TEXTURE_2D, font_tex)
    gl.uniform1i(gl.getUniformLocation(draw_program, "cells"), 0)
    gl.uniform1i(gl.getUniformLocation(draw_program, "font"), 1)

    gl.uniform2f(
        gl.getUniformLocation(draw_program, "screen_size"),
        canvas.width, canvas.height,
    )
    gl.uniform1f(
        gl.getUniformLocation(draw_program, "zoom_scale"),
        zoom.scale,
    )
    gl.uniform2f(
        gl.getUniformLocation(draw_program, "offset"),
        -pan.x, pan.y,
    )
    gl.uniform1i(
        gl.getUniformLocation(draw_program, "time_step"),
        time_step,
    )
    gl.uniform1i(
        gl.getUniformLocation(draw_program, "do_fix"),
        do_fix,
    )

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
}
do_fix = true
</script>


<script id="webgl_setup">
const canvas = document.querySelector("canvas")
canvas.width = innerWidth
canvas.height = innerHeight
const gl = canvas.getContext("webgl2")

const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1])
const buffer = gl.createBuffer()
const fb = gl.createFramebuffer()

gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)

let grid_cells = [new_tex(grid_size), new_tex(grid_size)]
let font_tex
let sim_program, interact_program, draw_program

function load_webgl() {
    // load shaders
    const source = id => document.getElementById(id).innerText.trim()
    const vert_source = source("vert")
    sim_program = create_program(
        vert_source, source("frag_sim"),
    )
    interact_program = create_program(
        vert_source, source("frag_interact")
    )
    draw_program = create_program(
        vert_source, source("frag_draw")
    )

    // make font texture
    const tc = document.createElement("canvas")
    tc.width = 480
    tc.height = 60
    const ctx = tc.getContext("2d")
    ctx.font = "80px Courier New"
    ctx.fillStyle = "white"
    ctx.fillText("0123456789", 0, 56)
    font_tex = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, font_tex)
    gl.texImage2D(
        gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tc,
    )
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
}

function compile_shader(source, type) {
    const shader = gl.createShader(type)
    gl.shaderSource(shader, source)
    gl.compileShader(shader)
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(shader))

    return shader
}

function create_program(vert_source, frag_source) {
    const program = gl.createProgram()
    gl.attachShader(
        program, compile_shader(vert_source, gl.VERTEX_SHADER)
    )
    gl.attachShader(
        program, compile_shader(frag_source, gl.FRAGMENT_SHADER)
    )
    gl.linkProgram(program)
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
        console.error(gl.getProgramInfoLog(program))

    return program
}

function new_tex(size) {
    const tex = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, tex)
    const pixels = new Uint8Array(size * size).map(
        () => Math.random() * 128 + 128
    )
    gl.texImage2D(
        gl.TEXTURE_2D, 0, gl.R8, size, size, 0,
        gl.RED, gl.UNSIGNED_BYTE, pixels,
    )
    gl.texParameteri(
        gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST,
    )
    gl.texParameteri(
        gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST,
    )

    return tex
}
</script>

</body>
</html>
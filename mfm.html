<!DOCTYPE html>
<html>
<head>
<title>mfm</title>
<link rel="icon" type="image/png" href="img/SelfImage.png" />
</head>
<body style="margin: 0; overflow: hidden; background-color: #222">
<canvas style="display: block"></canvas>

<script id="main">
const grid_size = 256

onload = function() {
    load_webgl()
    loop()
}

function loop() {
    fix_size()
    update_cam()

    if (mouse_held(0)) {
        interact()
    }

    if (!paused) sim_step()
    draw()

    mouse.px = mouse.x
    mouse.py = mouse.y

    requestAnimationFrame(loop)
}
</script>


<script id="controls">
let paused = false
const mouse = {
    x: 0, y: 0,
    px: 0, py: 0,
    held: { 0: false, 1: false, 2: false },
}

function mouse_held(button) {
    if (button === undefined) {
        for (const b in mouse.held) {
            if (mouse.held[b]) {
                return true
            }
        }
        return false
    }
    return button in mouse.held && mouse.held[button]
}

onmousemove = e => {
    mouse.x = e.x
    mouse.y = e.y
}
onwheel = e => {
    zoom.vel_factor -= e.deltaY / 2000   
}
oncontextmenu = e => e.preventDefault()
onmousedown = e => {
    if (e.button in mouse.held) {
        mouse.held[e.button] = true
    }
    if (e.button === 2) {
        pan.held = true
    }
}
onmouseup = e => {
    if (e.button in mouse.held) {
        mouse.held[e.button] = false
    }
    if (e.button === 2) {
        pan.held = false
    }
}
onmouseleave = e => {
    pan.held = false
}

onkeydown = e => {
    if (e.key === " ") {
        paused = !paused
    } else if (e.key === "ArrowRight") {
        sim_step()
    }
}
</script>


<script id="camera">
const pan = {
    x: 0, y: 0,
    xv: 0, yv: 0,
    held: false,
}
const zoom = {
    scale: 1,
    min_scale: 1,
    max_scale: 20,
    vel_factor: 1,
}

function update_cam() {
    // zoom
    const pscale1 = zoom.scale
    zoom.vel_factor = clamp(zoom.vel_factor, 0.5, 2.0)
    zoom.scale *= zoom.vel_factor
    const pscale2 = zoom.scale
    // elastic bounds
    const log_zoom = log2(zoom.scale)
    const log_min = log2(zoom.min_scale)
    const log_max = log2(zoom.max_scale)
    const log_target = log_zoom < log_min ? log_min : (
        log_zoom > log_max ? log_max : log_zoom
    )
    const bounce_factor = 1 - pow(
        1.7,
        -pow(abs(log_zoom - log_target) * 0.5, 0.5),
    )
    zoom.scale = pow(2, lerp(log_zoom, log_target, bounce_factor))
    zoom.vel_factor = lerp(
        zoom.vel_factor, 1, 0.2 * pow(3, -bounce_factor * 2)
    )

    // update pan to keep mouse in place
    // (or more slidey for elastic scaling)
    const short_edge = min(innerWidth, innerHeight)
    const mouse_uv = [
        (mouse.x - innerWidth / 2) / short_edge,
        (mouse.y - innerHeight / 2) / short_edge,
    ]
    const pan_factor = 1 / pscale1 - 1 / zoom.scale

    if (zoom.scale > zoom.min_scale && zoom.scale < zoom.max_scale) {
        pan.x -= mouse_uv[0] * pan_factor
        pan.y -= mouse_uv[1] * pan_factor
    } else if (
        zoom.scale < zoom.min_scale && pan_factor <= 0
        || zoom.scale > zoom.min_scale && pan_factor >= 0
    ) {
        const pan_factor_scroll = 1 / pscale1 - 1 / pscale2
        const a = 0.2
        // it just works tm
        const f = pan_factor + a * exp(
            (pan_factor_scroll - pan_factor) / a
        ) - a
        const cur_d = pow(pan.xv, 2) + pow(pan.yv, 2)
        const prop_d = (
            pow(mouse_uv[0] * f, 2)
            + pow(mouse_uv[1] * f, 2)
        )
        if (prop_d > cur_d) {
            pan.xv = -mouse_uv[0] * f
            pan.yv = -mouse_uv[1] * f
        }
    }

    // pan
    // todo: framerate independence, mouse velocity smoothing
    if (pan.held) {
        const dx = (mouse.x - mouse.px) / zoom.scale / short_edge
        const dy = (mouse.y - mouse.py) / zoom.scale / short_edge
        pan.xv = dx
        pan.yv = dy
        pan.x += dx
        pan.y += dy
    } else {
        pan.x += pan.xv
        pan.y += pan.yv
        pan.xv *= 0.9
        pan.yv *= 0.9
    }
}

const log2 = Math.log2
const exp = Math.exp
const pow = Math.pow
const abs = Math.abs
const min = Math.min
const max = Math.max
function clamp(x, a, b) {
    return min(max(x, a), b)
}
function lerp(a, b, t) {
    return a * (1 - t) + b * t
}
function inv_lerp(a, b, x) {
    if (b - a === 0) return 0 
    return (x - a) / (b - a)
}
function mod(x, n) {
    return ((x % n) + n) % n
}
</script>


<script type="x-shader/x-vertex" id="vert">
#version 300 es
in vec2 pos;
out vec2 uv;

void main() {
    gl_Position = vec4(pos, 0, 1);
    uv = pos * 0.5 + 0.5;
}
</script>


<script type="x-shader/x-fragment" id="frag_sim">
#version 300 es
precision highp float;
precision highp int;

out float cell;

uniform sampler2D cells;
uniform int time_step;

vec3 hash(ivec3 ix) {
    // source: https://www.shadertoy.com/view/XlXcW4
    uvec3 x = uvec3(ix);
    const uint k = 1103515245U;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    return vec3(x) * (1.0 / float(0xffffffffU));
}

void main() {
    ivec2 p = ivec2(gl_FragCoord.xy);

    // cycle through 2-cell event window grid alignments & phases
    // note: has some directional bias
    ivec2 dir = bool(time_step % 2) ? ivec2(1, 0) : ivec2(0, 1);
    int grid_phase = (time_step / 2) % 2;
    int cell_phase = ((p.x * dir.x + p.y * dir.y) + grid_phase) % 2;
    ivec2 window_p = p - cell_phase * dir;

    vec3 rng = hash(ivec3(window_p, time_step));
    bool swap = rng.g < 0.5;
    if (swap) {
        vec2 res = vec2(textureSize(cells, 0));
        float other_cell = texture(
            cells,
            vec2(window_p + dir * (1 - cell_phase)) / res
        ).r;
        cell = other_cell;
    } else {
        cell = min(
            texelFetch(cells, p, 0).r + 0.005,
            0.8 + rng.b * 0.2
        );
    }
}
</script>


<script type="x-shader/x-fragment" id="frag_interact">
#version 300 es
precision mediump float;
out float cell;

uniform sampler2D cells;
uniform int time_step;
uniform vec2 mouse;
uniform float brush_size;

vec3 hash(ivec3 ix) {
    // source: https://www.shadertoy.com/view/XlXcW4
    uvec3 x = uvec3(ix);
    const uint k = 1103515245U;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    return vec3(x) * (1.0 / float(0xffffffffU));
}

void main() {
    ivec2 p = ivec2(gl_FragCoord.xy);
    vec2 size = vec2(textureSize(cells, 0));
    vec2 uv = vec2(p) / size;

    for (int i = -1; i <= 1; ++i) {
        for (int j = -1; j <= 1; ++j) {
            vec2 uv_tile = uv + vec2(i, j);
            if (distance(uv_tile, mouse) < brush_size) {
                cell = hash(ivec3(p, time_step)).r / 2.0;
                return;
            }
        }
    }
    cell = texelFetch(cells, p, 0).r;
}
</script>


<script type="x-shader/x-fragment" id="frag_draw">
#version 300 es
precision mediump float;
in vec2 uv;
out vec4 color;

uniform sampler2D cells;
uniform sampler2D font;
uniform vec2 screen_size;
uniform float zoom_scale;
uniform vec2 offset;

vec2 get_cam_uv() {
    vec2 ss = screen_size;
    vec2 aspect_scale = ss / min(ss.x, ss.y);
    return 0.5 + (uv - 0.5) * aspect_scale / zoom_scale + offset;
}

void main() {
    vec2 cam_uv = get_cam_uv();
    float value = texture(cells, cam_uv).r;

    // numbers
    vec2 cs = vec2(textureSize(cells, 0));
    vec2 cell_uv = mod(cam_uv * cs, vec2(1.0));
    cell_uv = clamp(cell_uv * 2.0 - 0.5, vec2(0.0), vec2(1.0));
    float display_num = round(value * 9.0);
    vec2 num_uv = (
        cell_uv + vec2(display_num, 0.0)
    ) / vec2(10.0, 1.0);
    num_uv.y = 1.0 - num_uv.y;
    float num_visibility = smoothstep(
        0.1, log2(20.0), log2(zoom_scale)
    );
    float num_value = texture(font, num_uv).a * num_visibility;
    value = mix(value, mod(value + 0.5, 1.0), num_value);

    color = vec4(vec3(value), 1.0);
}
</script>


<script id="webgl_loop">
let time_step = 0

function fix_size() {
    if (
        canvas.width !== innerWidth
        || canvas.height !== innerHeight
    ) {
        canvas.width = innerWidth
        canvas.height = innerHeight
    }
    gl.viewport(0, 0, canvas.width, canvas.height)
}

function sim_step() {
    gl.useProgram(sim_program)
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb)
    gl.framebufferTexture2D(
        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
        grid_cells[1], 0,
    )
    gl.bindTexture(gl.TEXTURE_2D, grid_cells[0])
    gl.uniform1i(
        gl.getUniformLocation(sim_program, "time_step"),
        time_step,
    )
    gl.enableVertexAttribArray(0)
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0)
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
    grid_cells = [grid_cells[1], grid_cells[0]]
    time_step++
}

function interact() {
    // get mouse cam coords
    const short_edge = min(innerWidth, innerHeight)
    const scale = short_edge * zoom.scale
    const mx = mod(
        0.5 + (mouse.x - innerWidth / 2) / scale - pan.x,
        1,
    )
    const my = mod(
        0.5 - (mouse.y - innerHeight / 2) / scale + pan.y,
        1,
    )

    // bloatware for the draw call
    gl.useProgram(interact_program)
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb)
    gl.framebufferTexture2D(
        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
        grid_cells[1], 0,
    )
    gl.activeTexture(gl.TEXTURE0)
    gl.bindTexture(gl.TEXTURE_2D, grid_cells[0])
    gl.uniform1i(
        gl.getUniformLocation(interact_program, "time_step"),
        time_step,
    )
    gl.uniform2f(
        gl.getUniformLocation(interact_program, "mouse"),
        mx, my,
    )
    gl.uniform1f(
        gl.getUniformLocation(interact_program, "brush_size"),
        0.05 / zoom.scale,
    )
    gl.enableVertexAttribArray(0)
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0)
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
    grid_cells = [grid_cells[1], grid_cells[0]]
}

function draw() {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null)
    gl.useProgram(draw_program)

    gl.activeTexture(gl.TEXTURE0)
    gl.bindTexture(gl.TEXTURE_2D, grid_cells[0])
    gl.activeTexture(gl.TEXTURE1)
    gl.bindTexture(gl.TEXTURE_2D, font_tex)
    gl.uniform1i(gl.getUniformLocation(draw_program, "cells"), 0)
    gl.uniform1i(gl.getUniformLocation(draw_program, "font"), 1)

    gl.uniform2f(
        gl.getUniformLocation(draw_program, "screen_size"),
        canvas.width, canvas.height,
    )
    gl.uniform1f(
        gl.getUniformLocation(draw_program, "zoom_scale"),
        zoom.scale,
    )
    gl.uniform2f(
        gl.getUniformLocation(draw_program, "offset"),
        -pan.x, pan.y,
    )
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
}
</script>


<script id="webgl_setup">
const canvas = document.querySelector("canvas")
canvas.width = innerWidth
canvas.height = innerHeight
const gl = canvas.getContext("webgl2")

const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1])
const buffer = gl.createBuffer()
const fb = gl.createFramebuffer()

gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)

let grid_cells = [new_tex(grid_size), new_tex(grid_size)]
let font_tex
let sim_program, interact_program, draw_program

function load_webgl() {
    // load shaders
    const source = id => document.getElementById(id).innerText.trim()
    const vert_source = source("vert")
    sim_program = create_program(
        vert_source, source("frag_sim"),
    )
    interact_program = create_program(
        vert_source, source("frag_interact")
    )
    draw_program = create_program(
        vert_source, source("frag_draw")
    )

    // make font texture
    const tc = document.createElement("canvas")
    tc.width = 480
    tc.height = 60
    const ctx = tc.getContext("2d")
    ctx.font = "80px Courier New"
    ctx.fillStyle = "white"
    ctx.fillText("0123456789", 0, 56)
    font_tex = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, font_tex)
    gl.texImage2D(
        gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tc,
    )
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
}

function compile_shader(source, type) {
    const shader = gl.createShader(type)
    gl.shaderSource(shader, source)
    gl.compileShader(shader)
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(shader))

    return shader
}

function create_program(vert_source, frag_source) {
    const program = gl.createProgram()
    gl.attachShader(
        program, compile_shader(vert_source, gl.VERTEX_SHADER)
    )
    gl.attachShader(
        program, compile_shader(frag_source, gl.FRAGMENT_SHADER)
    )
    gl.linkProgram(program)
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
        console.error(gl.getProgramInfoLog(program))

    return program
}

function new_tex(size) {
    const tex = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, tex)
    const pixels = new Uint8Array(size * size).map(
        () => Math.random() * 128 + 128
    )
    gl.texImage2D(
        gl.TEXTURE_2D, 0, gl.R8, size, size, 0,
        gl.RED, gl.UNSIGNED_BYTE, pixels,
    )
    gl.texParameteri(
        gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST,
    )
    gl.texParameteri(
        gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST,
    )

    return tex
}
</script>

</body>
</html>
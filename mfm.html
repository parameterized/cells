<!DOCTYPE html>
<html>
<head>
<title>mfm</title>
<link rel="icon" type="image/png" href="img/SelfImage.png" />
</head>
<body style="margin: 0; overflow: hidden; background-color: #222">
<canvas style="display: block"></canvas>

<script id="main">
const grid_size = 256

onload = function() {
    load_webgl()
    loop()
}

function loop() {
    fix_size()
    update_cam()

    if (mouse_held(0)) {
        interact()
    }

    if (!paused) sim_step()
    draw()

    mouse.px = mouse.x
    mouse.py = mouse.y

    requestAnimationFrame(loop)
}
</script>


<script id="controls">
let paused = false
const mouse = {
    x: 0, y: 0,
    px: 0, py: 0,
    held: { 0: false, 1: false, 2: false },
}

function mouse_held(button) {
    if (button === undefined) {
        for (const b in mouse.held) {
            if (mouse.held[b]) {
                return true
            }
        }
        return false
    }
    return button in mouse.held && mouse.held[button]
}

onmousemove = e => {
    mouse.x = e.x
    mouse.y = e.y
}
onwheel = e => {
    zoom.vel_factor -= e.deltaY / 2000   
}
oncontextmenu = e => e.preventDefault()
onmousedown = e => {
    if (e.button in mouse.held) {
        mouse.held[e.button] = true
    }
    if (e.button === 2) {
        pan.held = true
    }
}
onmouseup = e => {
    if (e.button in mouse.held) {
        mouse.held[e.button] = false
    }
    if (e.button === 2) {
        pan.held = false
    }
}
onmouseleave = e => {
    pan.held = false
}

onkeydown = e => {
    if (e.key === " ") {
        paused = !paused
    }
}
</script>


<script id="camera">
const pan = {
    x: 0, y: 0,
    xv: 0, yv: 0,
    held: false,
}
const zoom = {
    scale: 1,
    max_scale: 20,
    vel_factor: 1,
}

function update_cam() {
    // todo: framerate independence, mouse velocity smoothing
    const short_edge = min(innerWidth, innerHeight)
    if (pan.held) {
        const dx = (mouse.x - mouse.px) / zoom.scale / short_edge
        const dy = (mouse.y - mouse.py) / zoom.scale / short_edge
        pan.xv = dx
        pan.yv = dy
        pan.x += dx
        pan.y += dy
    } else {
        pan.xv *= 0.9
        pan.yv *= 0.9
        pan.x += pan.xv
        pan.y += pan.yv
    }

    // zoom
    const pscale = zoom.scale
    zoom.scale *= zoom.vel_factor
    zoom.max_scale = 20
    zoom.scale = clamp(zoom.scale, 0.5, zoom.max_scale)
    zoom.vel_factor = lerp(zoom.vel_factor, 1, 0.2)

    // update pan to keep mouse in place
    const mouse_uv = [
        (mouse.x - innerWidth / 2) / short_edge,
        (mouse.y - innerHeight / 2) / short_edge,
    ]
    const delta_uv = [
        mouse_uv[0] * (1 / pscale - 1 / zoom.scale),
        mouse_uv[1] * (1 / pscale - 1 / zoom.scale),
    ]
    pan.x -= delta_uv[0]
    pan.y -= delta_uv[1]
}

const min = Math.min
const max = Math.max
function clamp(x, a, b) {
    return min(max(x, a), b)
}
function lerp(a, b, t) {
    return a * (1 - t) + b * t
}
function mod(x, n) {
    return ((x % n) + n) % n
}
</script>


<script type="x-shader/x-vertex" id="vert">
#version 300 es
in vec2 pos;
out vec2 uv;

void main() {
    gl_Position = vec4(pos, 0, 1);
    uv = pos * 0.5 + 0.5;
}
</script>


<script type="x-shader/x-fragment" id="frag_sim">
#version 300 es
precision highp float;
precision highp int;

out float cell;

uniform sampler2D cells;
uniform int time_step;

vec3 hash(ivec3 ix) {
    // source: https://www.shadertoy.com/view/XlXcW4
    uvec3 x = uvec3(ix);
    const uint k = 1103515245U;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    return vec3(x) * (1.0 / float(0xffffffffU));
}

void main() {
    ivec2 p = ivec2(gl_FragCoord.xy);

    // cycle through 2-cell event window grid alignments & phases
    // note: has some directional bias
    ivec2 dir = bool(time_step % 2) ? ivec2(1, 0) : ivec2(0, 1);
    int grid_phase = (time_step / 2) % 2;
    int cell_phase = ((p.x * dir.x + p.y * dir.y) + grid_phase) % 2;
    ivec2 window_p = p - cell_phase * dir;

    vec3 rng = hash(ivec3(window_p, time_step));
    bool swap = rng.g < 0.5;
    if (swap) {
        vec2 res = vec2(textureSize(cells, 0));
        float other_cell = texture(
            cells,
            vec2(window_p + dir * (1 - cell_phase)) / res
        ).r;
        cell = other_cell;
    } else {
        cell = min(
            texelFetch(cells, p, 0).r + 0.005,
            0.8 + rng.b * 0.2
        );
    }
}
</script>


<script type="x-shader/x-fragment" id="frag_interact">
#version 300 es
precision mediump float;
out float cell;

uniform sampler2D cells;
uniform int time_step;
uniform vec2 mouse;
uniform float brush_size;

vec3 hash(ivec3 ix) {
    // source: https://www.shadertoy.com/view/XlXcW4
    uvec3 x = uvec3(ix);
    const uint k = 1103515245U;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    x = ((x >> 8U)^x.yzx) * k;
    return vec3(x) * (1.0 / float(0xffffffffU));
}

void main() {
    ivec2 p = ivec2(gl_FragCoord.xy);
    vec2 size = vec2(textureSize(cells, 0));
    vec2 uv = vec2(p) / size;

    for (int i = -1; i <= 1; ++i) {
        for (int j = -1; j <= 1; ++j) {
            vec2 uv_tile = uv + vec2(i, j);
            if (distance(uv_tile, mouse) < brush_size) {
                cell = hash(ivec3(p, time_step)).r / 2.0;
                return;
            }
        }
    }
    cell = texelFetch(cells, p, 0).r;
}
</script>


<script type="x-shader/x-fragment" id="frag_draw">
#version 300 es
precision mediump float;
in vec2 uv;
out vec4 color;

uniform sampler2D cells;
uniform vec2 screen_size;
uniform float zoom_scale;
uniform vec2 offset;

vec2 get_cam_uv() {
    vec2 ss = screen_size;
    vec2 aspect_scale = ss / min(ss.x, ss.y);
    return 0.5 + (uv - 0.5) * aspect_scale / zoom_scale + offset;
}

void main() {
    float value = texture(cells, get_cam_uv()).r;
    color = vec4(vec3(value), 1.0);
}
</script>


<script id="webgl_loop">
let time_step = 0

function fix_size() {
    if (
        canvas.width !== innerWidth
        || canvas.height !== innerHeight
    ) {
        canvas.width = innerWidth
        canvas.height = innerHeight
    }
    gl.viewport(0, 0, canvas.width, canvas.height)
}

function sim_step() {
    gl.useProgram(sim_program)
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb)
    gl.framebufferTexture2D(
        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
        textures[1], 0,
    )
    gl.bindTexture(gl.TEXTURE_2D, textures[0])
    gl.uniform1i(
        gl.getUniformLocation(sim_program, "time_step"),
        time_step,
    )
    gl.enableVertexAttribArray(0)
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0)
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
    textures = [textures[1], textures[0]]
    time_step++
}

function interact() {
    // get mouse cam coords
    const short_edge = min(innerWidth, innerHeight)
    const scale = short_edge * zoom.scale
    const mx = mod(
        0.5 + (mouse.x - innerWidth / 2) / scale - pan.x,
        1,
    )
    const my = mod(
        0.5 - (mouse.y - innerHeight / 2) / scale + pan.y,
        1,
    )

    // bloatware for the draw call
    gl.useProgram(interact_program)
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb)
    gl.framebufferTexture2D(
        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
        textures[1], 0,
    )
    gl.bindTexture(gl.TEXTURE_2D, textures[0])
    gl.uniform1i(
        gl.getUniformLocation(interact_program, "time_step"),
        time_step,
    )
    gl.uniform2f(
        gl.getUniformLocation(interact_program, "mouse"),
        mx, my,
    )
    gl.uniform1f(
        gl.getUniformLocation(interact_program, "brush_size"),
        0.05 / zoom.scale,
    )
    gl.enableVertexAttribArray(0)
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0)
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
    textures = [textures[1], textures[0]]
}

function draw() {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null)
    gl.useProgram(draw_program)
    gl.bindTexture(gl.TEXTURE_2D, textures[0])
    gl.uniform2f(
        gl.getUniformLocation(draw_program, "screen_size"),
        canvas.width, canvas.height,
    )
    gl.uniform1f(
        gl.getUniformLocation(draw_program, "zoom_scale"),
        zoom.scale,
    )
    gl.uniform2f(
        gl.getUniformLocation(draw_program, "offset"),
        -pan.x, pan.y,
    )
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
}
</script>


<script id="webgl_setup">
const canvas = document.querySelector("canvas")
canvas.width = innerWidth
canvas.height = innerHeight
const gl = canvas.getContext("webgl2")

const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1])
const buffer = gl.createBuffer()
const fb = gl.createFramebuffer()

gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)

let textures = [new_tex(grid_size), new_tex(grid_size)]
let sim_program, interact_program, draw_program

function load_webgl() {
    const source = id => document.getElementById(id).innerText.trim()
    const vert_source = source("vert")
    sim_program = create_program(
        vert_source, source("frag_sim"),
    )
    interact_program = create_program(
        vert_source, source("frag_interact")
    )
    draw_program = create_program(
        vert_source, source("frag_draw")
    )
}

function compile_shader(source, type) {
    const shader = gl.createShader(type)
    gl.shaderSource(shader, source)
    gl.compileShader(shader)
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(shader))

    return shader
}

function create_program(vert_source, frag_source) {
    const program = gl.createProgram()
    gl.attachShader(
        program, compile_shader(vert_source, gl.VERTEX_SHADER)
    )
    gl.attachShader(
        program, compile_shader(frag_source, gl.FRAGMENT_SHADER)
    )
    gl.linkProgram(program)
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
        console.error(gl.getProgramInfoLog(program))

    return program
}

function new_tex(size) {
    const tex = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, tex)
    const pixels = new Uint8Array(size * size).map(
        () => Math.random() * 128 + 128
    )
    gl.texImage2D(
        gl.TEXTURE_2D, 0, gl.R8, size, size, 0,
        gl.RED, gl.UNSIGNED_BYTE, pixels,
    )
    gl.texParameteri(
        gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST,
    )
    gl.texParameteri(
        gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST,
    )

    return tex
}
</script>

</body>
</html>